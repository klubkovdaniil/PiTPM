1.-------------------------

«примитивныt» типы данных:
1. number - для любых чисел: целочисленных или чисел с плавающей точкой; 
целочисленные значения ограничены диапазоном ±(253-1).
2. bigint - для целых чисел произвольной длины.
3. string - для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
4. boolean - для true/false.
5. null - для неизвестных значений – отдельный тип, имеющий одно значение null.
6. undefined - для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
7. symbol - для уникальных идентификаторов.
Не является «примитивным» и стоит особняком:
8. object - для более сложных структур данных.

Переменные, объявленные с помощью ключевого слова «var», являются глобальными.
Это означает, что они доступны из любого места в коде.
Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости.
Разница между «let» и «const» состоит в том, что в первом случае мы может менять значение переменной, 
а во втором — нет.

hoisting — это механизм в JavaScript, в котором переменные и объявления функций, 
передвигаются вверх своей области видимости перед тем, как код будет выполнен.

2.-------------------------

function name(){}

Function Declaration – функция, объявленная в основном потоке кода. 
Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.

// Function Declaration
function sum(a, b) {
  return a + b;
}

// Function Expression
var sum = function(a, b) {
  return a + b;
}


простой и лаконичный синтаксис для создания функций
let sum = (a, b) => a + b;

3.-------------------------------

let user = new Object();
let name {}

arr.push(...items) – добавляет элементы в конец

arr.Foreach()

4.-------------------------------

element.addEventListener(event, handler, [options]);

event - Имя события, например "click".
handler - Ссылка на функцию-обработчик.
options - Дополнительный объект со свойствами

Делигирование событий. Из него можно получить целевой элемент event.target, 
понять на каком именно потомке произошло событие и обработать его.

5. -----------------------------

- синхронный — вы запускаете какой-то код, а результат возвращается, как только браузер может его вернуть.
ассинхронный - выполнение кода не следует обычному последовательному потоку сверху вниз. 
Вместо этого асинхронный код позволяет инициировать и выполнять определенные операции отдельно, не блокируя выполнение другого кода.
Есть два типа стиля асинхронного кода: 
старый метод — колбэки (callbacks) и более новый — промисы (promises).

- У слова async один простой смысл: эта функция всегда возвращает промис. 
Значения других типов оборачиваются в завершившийся успешно промис автоматически. 
Ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис.
Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. 
После чего оно вернёт его результат, и выполнение кода продолжится. await нельзя использовать в обычных функциях

Пример:
async function f() {
let promise = new Promise((resolve, reject) => {});
  let result = await promise;
  alert(result);
}
f();

- Promise – это специальный объект, который содержит своё состояние. 
Вначале pending («ожидание»), затем – одно из: 
fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).
Промис создаётся с помощью конструктора.
В конструктор передаётся функция-исполнитель асинхронной операции. 
Она вызывается сразу после создания промиса. 
Задача этой функции — выполнить асинхронную операцию и перевести состояние промиса в fulfilled (успех) или rejected (ошибка).
